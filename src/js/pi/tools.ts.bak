import fs from "node:fs";
import path from "node:path";
import { exec } from "node:child_process";
import type { AgentTool } from "@mariozechner/pi-agent-core";
import { runSkill } from "../skills/registry.js";
import { searchWebWithOptions } from "../tools/web.js";

const WORKSPACE_ROOT = path.resolve(process.cwd());
const DEFAULT_MAX_DEPTH = 2;
const MAX_FILE_BYTES = 512 * 1024;
const SEARCH_EXCLUDES = new Set(["node_modules", "dist", "sessions", "log", ".git"]);

function resolveWorkspacePath(inputPath: string): string {
  if (!inputPath) throw new Error("Missing path.");
  const resolved = path.resolve(WORKSPACE_ROOT, inputPath);
  if (resolved === WORKSPACE_ROOT) return resolved;
  if (!resolved.startsWith(`${WORKSPACE_ROOT}${path.sep}`)) {
    throw new Error("Path is Ø®Ø§Ø±Ø¬çš„ï¼Œå¿…é¡»ä½äº workspace ç›®å½•ä¸‹ã€‚");
  }
  return resolved;
}

function ensureParentDir(filePath: string): void {
  fs.mkdirSync(path.dirname(filePath), { recursive: true });
}

function listDirRecursive(
  current: string,
  depth: number,
  maxDepth: number,
  results: string[]
): void {
  if (depth > maxDepth) return;
  const entries = fs.readdirSync(current, { withFileTypes: true });
  for (const entry of entries) {
    if (SEARCH_EXCLUDES.has(entry.name)) continue;
    const full = path.join(current, entry.name);
    const rel = path.relative(WORKSPACE_ROOT, full) || ".";
    if (entry.isDirectory()) {
      results.push(`${rel}/`);
      listDirRecursive(full, depth + 1, maxDepth, results);
    } else {
      results.push(rel);
    }
  }
}

function searchTextInDir(
  base: string,
  matcher: (content: string) => boolean,
  results: string[],
  maxResults: number
): void {
  if (results.length >= maxResults) return;
  const entries = fs.readdirSync(base, { withFileTypes: true });
  for (const entry of entries) {
    if (results.length >= maxResults) return;
    if (SEARCH_EXCLUDES.has(entry.name)) continue;
    const full = path.join(base, entry.name);
    if (entry.isDirectory()) {
      searchTextInDir(full, matcher, results, maxResults);
      continue;
    }
    try {
      const stat = fs.statSync(full);
      if (stat.size > MAX_FILE_BYTES) continue;
      const content = fs.readFileSync(full, "utf-8");
      if (matcher(content)) {
        results.push(path.relative(WORKSPACE_ROOT, full));
      }
    } catch {
      // Ignore unreadable files.
    }
  }
}

async function execShell(command: string, timeoutMs: number): Promise<{ stdout: string; stderr: string }> {
  return new Promise((resolve, reject) => {
    exec(
      command,
      { cwd: WORKSPACE_ROOT, timeout: timeoutMs, maxBuffer: 512 * 1024 },
      (error, stdout, stderr) => {
        if (error) {
          const message = stderr || error.message || String(error);
          reject(new Error(message.trim() || "Command failed."));
          return;
        }
        resolve({ stdout, stderr });
      }
    );
  });
}

export type UpdateEnvConfigOptions = {
  key: string;
  value: string;
  comment?: string;
};

export function updateEnvConfig(options: UpdateEnvConfigOptions): {
  key: string;
  updated: boolean;
} {
  const { key, value, comment } = options;

  if (!key || !/^[A-Z][A-Z0-9_]*$/.test(key)) {
    throw new Error("ç¯å¢ƒå˜é‡åç§°å¿…é¡»ä¸ºå¤§å†™å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿ç»„æˆï¼Œä¸”ä»¥å­—æ¯å¼€å¤´ã€‚");
  }

  const envPath = path.resolve(WORKSPACE_ROOT, ".env");
  let envContent = "";

  if (fs.existsSync(envPath)) {
    envContent = fs.readFileSync(envPath, "utf-8");
  }

  const lines = envContent.split("\n");
  let found = false;
  let updated = false;

  // æŸ¥æ‰¾å¹¶æ›´æ–°ç°æœ‰çš„é…ç½®
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line.startsWith(`${key}=`)) {
      const oldValue = line.substring(key.length + 1);
      if (oldValue !== value) {
        lines[i] = `${key}=${value}`;
        updated = true;
      }
      found = true;
      break;
    }
  }

  // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œæ·»åŠ æ–°é…ç½®
  if (!found) {
    // ç¡®ä¿æ–‡ä»¶æœ«å°¾æœ‰ç©ºè¡Œ
    if (lines.length > 0 && lines[lines.length - 1].trim() !== "") {
      lines.push("");
    }

    // æ·»åŠ æ³¨é‡Šï¼ˆå¦‚æœæœ‰ï¼‰
    if (comment) {
      lines.push(`# ${comment}`);
    }

    lines.push(`${key}=${value}`);
    updated = true;
  }

  if (updated) {
    fs.writeFileSync(envPath, lines.join("\n"));
  }

  return { key, updated };
}

export type CreateSkillTemplateOptions = {
  name: string;
  description?: string;
  overwrite?: boolean;
};

export function createSkillTemplate(options: CreateSkillTemplateOptions): {
  name: string;
} {
  const rawName = String(options.name || "").trim();
  if (!rawName) {
    throw new Error("name ä¸èƒ½ä¸ºç©ºã€‚");
  }
  if (!/^[a-z0-9][a-z0-9-_]*$/i.test(rawName)) {
    throw new Error("name ä»…æ”¯æŒå­—æ¯/æ•°å­—/-/_ï¼Œä¸”éœ€ä»¥å­—æ¯æˆ–æ•°å­—å¼€å¤´ã€‚");
  }

  const dirPath = resolveWorkspacePath(path.join("skills", rawName));
  const skillPath = path.join(dirPath, "SKILL.md");
  const readmePath = path.join(dirPath, "README.md");
  const overwrite = Boolean(options.overwrite);
  const desc = String(options.description || `Skill ${rawName}`).trim();

  if (!overwrite) {
    if (fs.existsSync(skillPath) || fs.existsSync(readmePath)) {
      throw new Error("æŠ€èƒ½å·²å­˜åœ¨ï¼Œè‹¥è¦è¦†ç›–è¯·è®¾ç½® overwrite=trueã€‚");
    }
  }

  fs.mkdirSync(dirPath, { recursive: true });
  const template = [
    "---",
    `name: ${rawName}`,
    `description: ${desc.replace(/\\n+/g, " ").trim()}`,
    "---",
    "",
    `# ${rawName}`,
    "",
    "## Purpose",
    "Describe what this skill does and when it should be used.",
    "",
    "## Inputs",
    "List required/optional inputs. If JSON, include the schema.",
    "",
    "## Output",
    "Define the expected output format and any constraints.",
    "",
    "## Steps",
    "1. Step one",
    "2. Step two",
    "",
    "## Guardrails",
    "- Ask for missing required inputs.",
    "- Keep outputs concise.",
    ""
  ].join("\n");
  fs.writeFileSync(skillPath, template);

  const readme = [
    `# ${rawName}`,
    "",
    desc,
    "",
    "## Input",
    "- Use the SKILL.md template to define required inputs.",
    "",
    "## Output",
    "- Define the response format in SKILL.md.",
    "",
    "## Example",
    "```md",
    "---",
    `name: ${rawName}`,
    `description: ${desc.replace(/\\n+/g, " ").trim()}`,
    "---",
    "",
    "# Skill Title",
    "## Purpose",
    "## Inputs",
    "## Output",
    "## Steps",
    "```",
    ""
  ].join("\n");
  fs.writeFileSync(readmePath, readme);

  return { name: rawName };
}

/**
 * æ‰«æå¹¶è·å–æ‰€æœ‰å¯ç”¨çš„ skills
 * ä» skills/ ç›®å½•ä¸­è¯»å–æ¯ä¸ª skill çš„ SKILL.md æ–‡ä»¶
 *
 * ğŸ”‘ åªæ³¨å†Œæœ‰çœŸå®å®ç°ï¼ˆindex.ts/index.jsï¼‰çš„ skills
 * æ²¡æœ‰å®ç°çš„ skillsï¼ˆå¦‚åªæœ‰ SKILL.md çš„ LLM-based skillsï¼‰ä¸ä¼šè¢«æ³¨å†Œä¸ºç‹¬ç«‹å·¥å…·
 * è¿™æ · LLM ä¼šæ™ºèƒ½åœ°ä½¿ç”¨å…¶ä»–å·¥å…·ï¼ˆå¦‚ web_searchï¼‰å®Œæˆä»»åŠ¡
 */
function getAllSkills(): Array<{ name: string; description: string }> {
  const skills: Array<{ name: string; description: string }> = [];
  const skillsDir = path.resolve(WORKSPACE_ROOT, "skills");

  if (!fs.existsSync(skillsDir)) {
    return skills;
  }

  try {
    const entries = fs.readdirSync(skillsDir, { withFileTypes: true });

    for (const entry of entries) {
      if (!entry.isDirectory()) continue;
      if (entry.name.startsWith("_")) continue; // è·³è¿‡ _shared ç­‰ç‰¹æ®Šç›®å½•

      const skillPath = path.join(skillsDir, entry.name, "SKILL.md");

      if (!fs.existsSync(skillPath)) continue;

      // ğŸ”‘ æ£€æŸ¥æ˜¯å¦æœ‰çœŸå®å®ç°
      const implPathTs = path.join(skillsDir, entry.name, "index.ts");
      const implPathJs = path.join(skillsDir, entry.name, "index.js");
      const hasImpl = fs.existsSync(implPathTs) || fs.existsSync(implPathJs);

      if (!hasImpl) {
        // è·³è¿‡æ²¡æœ‰å®ç°çš„ skillï¼ˆLLM ä¼šä½¿ç”¨å…¶ä»–å·¥å…·å¦‚ web_searchï¼‰
        console.log(`[Skills] Skipping ${entry.name}: no implementation (LLM-based skill, not registered as tool)`);
        continue;
      }

      try {
        const content = fs.readFileSync(skillPath, "utf-8");

        // æå– frontmatter ä¸­çš„ description
        const frontmatterMatch = content.match(/^---\s*\n([\s\S]*?)\n---/);
        let description = `Execute ${entry.name} skill`;

        if (frontmatterMatch) {
          const frontmatter = frontmatterMatch[1];
          const descMatch = frontmatter.match(/description:\s*(.+)/);
          if (descMatch) {
            description = descMatch[1].trim();
          }
        }

        skills.push({
          name: entry.name,
          description
        });

        console.log(`[Skills] Registered ${entry.name} as tool (has implementation)`);
      } catch (error) {
        // è·³è¿‡è¯»å–å¤±è´¥çš„ skill
        console.warn(`Failed to read skill ${entry.name}:`, error);
      }
    }
  } catch (error) {
    console.warn("Failed to scan skills directory:", error);
  }

  console.log(`[Skills] Total registered tools: ${skills.length}`);
  return skills;
}

export function createPiTools(): AgentTool<any>[] {
  const baseTools = [
    {
      name: "read_file",
      label: "Read File",
      description: "Read a UTF-8 text file from the workspace.",
      parameters: {
        type: "object",
        properties: {
          path: { type: "string", description: "Path relative to workspace." }
        },
        required: ["path"]
      } as any,
      execute: async (_toolCallId: string, params: any) => {
        const filePath = resolveWorkspacePath(params.path);
        const content = fs.readFileSync(filePath, "utf-8");
        return {
          content: [{ type: "text" as const, text: content }],
          details: { path: params.path }
        };
      }
    },
    {
      name: "write_file",
      label: "Write File",
      description: "Write UTF-8 text to a file (creates directories if needed).",
      parameters: {
        type: "object",
        properties: {
          path: { type: "string", description: "Path relative to workspace." },
          content: { type: "string", description: "File contents." }
        },
        required: ["path", "content"]
      } as any,
      execute: async (_toolCallId, params) => {
        const filePath = resolveWorkspacePath(params.path);
        ensureParentDir(filePath);
        fs.writeFileSync(filePath, params.content ?? "");
        return {
          content: [{ type: "text", text: "ok" }],
          details: { path: params.path }
        };
      }
    },
    {
      name: "edit_file",
      label: "Edit File",
      description: "Replace text in a file. Provide oldText and newText.",
      parameters: {
        type: "object",
        properties: {
          path: { type: "string", description: "Path relative to workspace." },
          oldText: { type: "string", description: "Text to replace." },
          newText: { type: "string", description: "Replacement text." },
          replaceAll: { type: "boolean", description: "Replace all occurrences." }
        },
        required: ["path", "oldText", "newText"]
      } as any,
      execute: async (_toolCallId, params) => {
        const filePath = resolveWorkspacePath(params.path);
        const content = fs.readFileSync(filePath, "utf-8");
        if (!params.oldText) {
          throw new Error("oldText ä¸èƒ½ä¸ºç©ºã€‚");
        }
        if (!content.includes(params.oldText)) {
          throw new Error("oldText æœªåŒ¹é…åˆ°æ–‡ä»¶å†…å®¹ã€‚");
        }
        const next = params.replaceAll
          ? content.split(params.oldText).join(params.newText)
          : content.replace(params.oldText, params.newText);
        fs.writeFileSync(filePath, next);
        return {
          content: [{ type: "text", text: "ok" }],
          details: { path: params.path }
        };
      }
    },
    {
      name: "list_dir",
      label: "List Dir",
      description: "List files and folders (optionally recursive).",
      parameters: {
        type: "object",
        properties: {
          path: { type: "string", description: "Path relative to workspace." },
          recursive: { type: "boolean", description: "List recursively." },
          maxDepth: { type: "number", description: "Max recursion depth." }
        },
        required: ["path"]
      } as any,
      execute: async (_toolCallId, params) => {
        const dirPath = resolveWorkspacePath(params.path);
        const results: string[] = [];
        if (params.recursive) {
          const depth = Number(params.maxDepth ?? DEFAULT_MAX_DEPTH);
          listDirRecursive(dirPath, 0, depth, results);
        } else {
          const entries = fs.readdirSync(dirPath, { withFileTypes: true });
          for (const entry of entries) {
            if (SEARCH_EXCLUDES.has(entry.name)) continue;
            results.push(entry.isDirectory() ? `${entry.name}/` : entry.name);
          }
        }
        return {
          content: [{ type: "text", text: results.join("\n") }],
          details: { path: params.path, count: results.length }
        };
      }
    },
    {
      name: "search_text",
      label: "Search Text",
      description: "Search text in files under a directory.",
      parameters: {
        type: "object",
        properties: {
          path: { type: "string", description: "Base directory relative to workspace." },
          pattern: { type: "string", description: "Text or regex pattern." },
          regex: { type: "boolean", description: "Treat pattern as regex." },
          caseSensitive: { type: "boolean", description: "Case sensitive search." },
          maxResults: { type: "number", description: "Max results." }
        },
        required: ["path", "pattern"]
      } as any,
      execute: async (_toolCallId, params) => {
        const base = resolveWorkspacePath(params.path);
        const maxResults = Number(params.maxResults ?? 50);
        const flags = params.caseSensitive ? "g" : "gi";
        const matcher = params.regex
          ? (content: string) => new RegExp(params.pattern, flags).test(content)
          : (content: string) =>
              params.caseSensitive
                ? content.includes(params.pattern)
                : content.toLowerCase().includes(String(params.pattern).toLowerCase());
        const results: string[] = [];
        searchTextInDir(base, matcher, results, maxResults);
        return {
          content: [{ type: "text", text: results.join("\n") }],
          details: { path: params.path, count: results.length }
        };
      }
    },
    {
      name: "run_shell",
      label: "Run Shell",
      description: "Run a shell command in workspace root.",
      parameters: {
        type: "object",
        properties: {
          command: { type: "string", description: "Shell command to execute." },
          timeoutMs: { type: "number", description: "Timeout in ms." }
        },
        required: ["command"]
      } as any,
      execute: async (_toolCallId, params) => {
        const timeoutMs = Number(params.timeoutMs ?? 15000);
        const { stdout, stderr } = await execShell(params.command, timeoutMs);
        const output = [stdout?.trim(), stderr?.trim()].filter(Boolean).join("\n");
        return {
          content: [{ type: "text", text: output || "ok" }],
          details: { command: params.command }
        };
      }
    },
    {
      name: "run_skill",
      label: "Run Skill",
      description: "è¿è¡Œ JPClaw æŠ€èƒ½ã€‚åªèƒ½æ‰§è¡Œæœ‰çœŸå®å®ç°ä»£ç ï¼ˆindex.ts/index.jsï¼‰çš„æŠ€èƒ½ã€‚å¯¹äºæ²¡æœ‰ä¸“ç”¨æŠ€èƒ½çš„ä»»åŠ¡ï¼ˆå¦‚å¤©æ°”æŸ¥è¯¢ï¼‰ï¼Œè¯·ä½¿ç”¨å…¶ä»–å·¥å…·å¦‚ web_search ä»£æ›¿ã€‚",
      parameters: {
        type: "object",
        properties: {
          name: { type: "string", description: "æŠ€èƒ½åç§°" },
          input: { type: "string", description: "æŠ€èƒ½è¾“å…¥" },
          scope: { type: "string", description: "å¯é€‰èŒƒå›´ï¼šskills æˆ– agents" }
        },
        required: ["name"]
      } as any,
      execute: async (_toolCallId, params) => {
        // ğŸ”‘ æ£€æŸ¥ skill æ˜¯å¦æœ‰å®ç°
        const skillsDir = path.resolve(WORKSPACE_ROOT, "skills");
        const implPathTs = path.join(skillsDir, params.name, "index.ts");
        const implPathJs = path.join(skillsDir, params.name, "index.js");
        const hasImpl = fs.existsSync(implPathTs) || fs.existsSync(implPathJs);

        if (!hasImpl) {
          // å¯¹äºæ— å®ç°çš„ skillï¼Œè¿”å›å‹å¥½æç¤º
          return {
            content: [{
              type: "text",
              text: `æŠ€èƒ½ '${params.name}' æ²¡æœ‰å®ç°ä»£ç ï¼ˆä»… LLM-based skillï¼‰ã€‚å¯¹äºéœ€è¦å®æ—¶æ•°æ®æˆ–å¤–éƒ¨ API çš„ä»»åŠ¡ï¼Œè¯·ä½¿ç”¨ web_search ç­‰å…¶ä»–å·¥å…·ä»£æ›¿ã€‚`
            }],
            details: { name: params.name, hasImplementation: false }
          };
        }

        const output = await runSkill(params.name, params.input || "", { scope: params.scope });
        return {
          content: [{ type: "text", text: output }],
          details: { name: params.name, hasImplementation: true }
        };
      }
    },
    {
      name: "create_skill_template",
      label: "Create Skill Template",
      description: "Create a new SKILL.md template under skills/<name>/.",
      parameters: {
        type: "object",
        properties: {
          name: { type: "string", description: "Skill folder/name (kebab-case recommended)." },
          description: { type: "string", description: "Short description for SKILL.md frontmatter." },
          overwrite: { type: "boolean", description: "Overwrite existing files." }
        },
        required: ["name"]
      } as any,
      execute: async (_toolCallId, params) => {
        const { name } = createSkillTemplate({
          name: params.name,
          description: params.description,
          overwrite: params.overwrite
        });

        return {
          content: [
            {
              type: "text",
              text: `created skills/${name}/SKILL.md, skills/${name}/README.md`
            }
          ],
          details: { name }
        };
      }
    },
    {
      name: "web_search",
      label: "Web Search",
      description: "Search the web for current information, news, and facts. Use this when you need up-to-date information or when the user asks about current events, news, people, companies, or any information not in your knowledge base.",
      parameters: {
        type: "object",
        properties: {
          query: { type: "string", description: "Search query." }
        },
        required: ["query"]
      } as any,
      execute: async (_toolCallId, params) => {
        const result = await searchWebWithOptions(params.query, { traceId: _toolCallId });
        return {
          content: [{ type: "text", text: result }],
          details: { query: params.query }
        };
      }
    },
    {
      name: "update_env_config",
      label: "Update Environment Config",
      description: "æ·»åŠ æˆ–æ›´æ–°é¡¹ç›® .env æ–‡ä»¶ä¸­çš„ç¯å¢ƒå˜é‡é…ç½®ã€‚ç”¨äºé…ç½® API Keysã€æœåŠ¡åœ°å€ç­‰ã€‚é…ç½®ä¼šç«‹å³å†™å…¥ .env æ–‡ä»¶ï¼Œä½†éœ€è¦é‡å¯æœåŠ¡æ‰èƒ½ç”Ÿæ•ˆã€‚",
      parameters: {
        type: "object",
        properties: {
          key: {
            type: "string",
            description: "ç¯å¢ƒå˜é‡åç§°ï¼ˆå¤§å†™å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ï¼Œä¾‹å¦‚ï¼šAMAP_API_KEYï¼‰"
          },
          value: {
            type: "string",
            description: "ç¯å¢ƒå˜é‡çš„å€¼"
          },
          comment: {
            type: "string",
            description: "å¯é€‰çš„æ³¨é‡Šè¯´æ˜ï¼ˆä¼šä½œä¸º # æ³¨é‡Šæ·»åŠ åˆ° .env ä¸­ï¼‰"
          }
        },
        required: ["key", "value"]
      } as any,
      execute: async (_toolCallId, params) => {
        const { key, updated } = updateEnvConfig({
          key: params.key,
          value: params.value,
          comment: params.comment
        });

        const message = updated
          ? `å·²${fs.existsSync(path.resolve(WORKSPACE_ROOT, ".env")) ? "æ›´æ–°" : "æ·»åŠ "} ${key} åˆ° .env æ–‡ä»¶`
          : `${key} å·²å­˜åœ¨ä¸”å€¼ç›¸åŒï¼Œæ— éœ€æ›´æ–°`;

        return {
          content: [
            {
              type: "text",
              text: `${message}\n\nâš ï¸ æç¤ºï¼šç¯å¢ƒå˜é‡é…ç½®å·²å†™å…¥ .env æ–‡ä»¶ï¼Œä½†éœ€è¦é‡å¯æœåŠ¡æ‰èƒ½ç”Ÿæ•ˆã€‚\nå»ºè®®ï¼šnpm run restart`
            }
          ],
          details: { key, updated }
        };
      }
    }
  ];

  // ğŸ”‘ åŠ¨æ€æ³¨å†Œæ‰€æœ‰ skills ä¸ºç‹¬ç«‹å·¥å…·
  const allSkills = getAllSkills();
  const skillTools: AgentTool<any>[] = allSkills.map(skill => ({
    name: skill.name,
    label: `${skill.name.charAt(0).toUpperCase()}${skill.name.slice(1)} Skill`,
    description: skill.description,
    parameters: {
      type: "object",
      properties: {
        input: {
          type: "string",
          description: "Input or query for the skill. For weather: city name(s), can be multiple cities separated by commas (e.g., 'åŒ—äº¬' or 'åŒ—äº¬,å¤©æ´¥')."
        }
      },
      required: []
    } as any,
    execute: async (_toolCallId, params) => {
      const input = params.input || "";
      const output = await runSkill(skill.name, input, { scope: "skills" });
      return {
        content: [{ type: "text", text: output }],
        details: { skillName: skill.name, input }
      };
    }
  }));

  return [...baseTools, ...skillTools];
}
