/**
 * Discord Multi-Bot Collaboration Orchestrator
 *
 * æ³›åŒ–çš„åä½œæœºåˆ¶ï¼š
 * - è‡ªåŠ¨æ£€æµ‹é¢‘é“ä¸­çš„botåŠå…¶è§’è‰²
 * - æŒ‰è§’è‰²ä¼˜å…ˆçº§ç¼–æ’è‡ªåŠ¨æ¥åŠ›
 * - é€‚é…ä»»æ„é¢‘é“ã€ä»»æ„botç»„åˆ
 */

import type { Message, Client } from "discord.js";
import { log } from "../shared/logger.js";

/**
 * è§’è‰²ä¼˜å…ˆçº§å®šä¹‰ï¼ˆå†³å®šæ¥åŠ›é¡ºåºï¼‰
 */
const ROLE_PRIORITY: Record<string, number> = {
  expert: 1,      // æ­£é¢ä¸“å®¶ - é¦–å…ˆå›ç­”
  critic: 2,       // åé¢è´¨ç–‘è€… - å…¶æ¬¡è´¨ç–‘
  thinker: 3        // æ·±åº¦æ€è€ƒè€… - æœ€åæ€»ç»“
};

/**
 * è§’è‰²æ˜¾ç¤ºåç§°
 */
const ROLE_DISPLAY_NAMES: Record<string, string> = {
  expert: "æ­£é¢ä¸“å®¶",
  critic: "åé¢è´¨ç–‘è€…",
  thinker: "æ·±åº¦æ€è€ƒè€…"
};

/**
 * Botä¿¡æ¯
 */
interface BotInfo {
  userId: string;
  agentId: string;
  username: string;
  priority: number;
}

/**
 * åä½œä¸Šä¸‹æ–‡
 */
interface CollaborationContext {
  channelId: string;
  originalMessageId: string;
  initiatorUserId: string;
  botsInChannel: BotInfo[];
  completedBots: Set<string>; // å·²å®Œæˆå›å¤çš„bot userId
}

/**
 * åä½œç¼–æ’å™¨
 */
export class CollaborationOrchestrator {
  // å­˜å‚¨æ¯ä¸ªæ¶ˆæ¯çš„åä½œä¸Šä¸‹æ–‡
  private contexts = new Map<string, CollaborationContext>();

  // Boté…ç½®æ˜ å°„ï¼šuserId -> agentId
  private botConfigs = new Map<string, string>();

  // è§¦å‘æ¶ˆæ¯ID -> åŸå§‹æ¶ˆæ¯ID çš„æ˜ å°„ï¼ˆè§£å†³åä½œé“¾ä¸­çš„æ¶ˆæ¯è¿½è¸ªé—®é¢˜ï¼‰
  private triggerMessageMap = new Map<string, string>();

  /**
   * æ³¨å†Œboté…ç½®
   */
  registerBot(userId: string, agentId: string): void {
    this.botConfigs.set(userId, agentId);
    log("info", "discord.collaboration.bot.registered", { userId, agentId });
  }

  /**
   * æ£€æµ‹é¢‘é“ä¸­çš„åä½œbot
   * ä½¿ç”¨å·²æ³¨å†Œçš„boté…ç½®ï¼Œé¿å…è°ƒç”¨ guild.members.fetch() è¶…æ—¶
   */
  async detectBotsInChannel(client: Client, channelId: string): Promise<BotInfo[]> {
    try {
      const bots: BotInfo[] = [];

      // ç›´æ¥ä½¿ç”¨å·²æ³¨å†Œçš„boté…ç½®
      for (const [userId, agentId] of this.botConfigs) {
        if (ROLE_PRIORITY[agentId] !== undefined) {
          // å°è¯•è·å–botçš„ç”¨æˆ·ä¿¡æ¯ï¼ˆä¸è·å–ä¹Ÿä¸å½±å“åŠŸèƒ½ï¼‰
          let username = `Bot_${agentId}`;
          try {
            const user = await client.users.fetch(userId);
            username = user.username;
          } catch {
            // è·å–å¤±è´¥ä¹Ÿä¸å½±å“ï¼Œä½¿ç”¨é»˜è®¤åç§°
          }

          bots.push({
            userId,
            agentId,
            username,
            priority: ROLE_PRIORITY[agentId]
          });
        }
      }

      // æŒ‰ä¼˜å…ˆçº§æ’åº
      bots.sort((a, b) => a.priority - b.priority);

      log("info", "discord.collaboration.bots.detected", {
        channelId,
        count: bots.length,
        bots: bots.map(b => ({ username: b.username, role: b.agentId }))
      });

      return bots;
    } catch (error) {
      log("error", "discord.collaboration.detect.failed", {
        channelId,
        error: String(error)
      });
      return [];
    }
  }

  /**
   * åˆå§‹åŒ–åä½œä¸Šä¸‹æ–‡ï¼ˆç”¨æˆ·å‘èµ·æé—®æ—¶ï¼‰
   */
  async initCollaboration(
    client: Client,
    message: Message,
    initiatorBotUserId: string
  ): Promise<void> {
    // åªæœ‰ç”¨æˆ·æ¶ˆæ¯æ‰èƒ½åˆå§‹åŒ–åä½œï¼Œbotæ¶ˆæ¯ä¸åº”è¯¥è§¦å‘æ–°çš„åä½œ
    if (message.author.bot) {
      log("debug", "discord.collaboration.skipped", {
        reason: "message_from_bot",
        authorId: message.author.id
      });
      return;
    }

    const botsInChannel = await this.detectBotsInChannel(client, message.channelId);

    // è‡³å°‘éœ€è¦2ä¸ªbotæ‰å¯ç”¨åä½œ
    if (botsInChannel.length < 2) {
      log("debug", "discord.collaboration.skipped", {
        reason: "not_enough_bots",
        count: botsInChannel.length
      });
      return;
    }

    const context: CollaborationContext = {
      channelId: message.channelId,
      originalMessageId: message.id,
      initiatorUserId: message.author.id,
      botsInChannel,
      completedBots: new Set()
    };

    this.contexts.set(message.id, context);

    log("info", "discord.collaboration.initialized", {
      messageId: message.id,
      channelId: message.channelId,
      botCount: botsInChannel.length,
      roles: botsInChannel.map(b => b.agentId)
    });
  }

  /**
   * Botå®Œæˆå›å¤åè°ƒç”¨ï¼ˆè§¦å‘ä¸‹ä¸€ä¸ªbotï¼‰
   */
  async onBotReplied(
    client: Client,
    originalMessageId: string,
    botUserId: string,
    replyMessage: Message
  ): Promise<void> {
    // å°è¯•é€šè¿‡è§¦å‘æ¶ˆæ¯æ˜ å°„æ‰¾åˆ°çœŸæ­£çš„åŸå§‹æ¶ˆæ¯ID
    const actualOriginalId = this.triggerMessageMap.get(originalMessageId) || originalMessageId;

    let context = this.contexts.get(actualOriginalId);

    // ã€æ–°é€»è¾‘ã€‘å¦‚æœæ²¡æœ‰åä½œä¸Šä¸‹æ–‡ï¼Œä¸”å½“å‰botæ˜¯expertï¼Œåˆ™åˆå§‹åŒ–åä½œ
    if (!context) {
      const botAgentId = this.botConfigs.get(botUserId);

      // åªæœ‰expertå›å¤åæ‰åˆå§‹åŒ–åä½œï¼ˆç”¨æˆ·åªèƒ½è§¦å‘expertï¼‰
      if (botAgentId === "expert") {
        log("info", "discord.collaboration.init_on_expert_reply", {
          originalMessageId: actualOriginalId,
          botUserId
        });

        // è·å–åŸå§‹ç”¨æˆ·æ¶ˆæ¯
        try {
          const channel = await client.channels.fetch(replyMessage.channelId);
          if (channel && "messages" in channel) {
            const originalMessage = await channel.messages.fetch(actualOriginalId);

            // åˆå§‹åŒ–åä½œä¸Šä¸‹æ–‡
            const botsInChannel = await this.detectBotsInChannel(client, replyMessage.channelId);
            if (botsInChannel.length >= 2) {
              context = {
                channelId: replyMessage.channelId,
                originalMessageId: actualOriginalId,
                initiatorUserId: originalMessage.author.id,
                botsInChannel,
                completedBots: new Set()
              };
              this.contexts.set(actualOriginalId, context);

              log("info", "discord.collaboration.initialized", {
                messageId: actualOriginalId,
                channelId: replyMessage.channelId,
                botCount: botsInChannel.length,
                roles: botsInChannel.map(b => b.agentId)
              });
            }
          }
        } catch (error) {
          log("error", "discord.collaboration.init_failed", {
            originalMessageId: actualOriginalId,
            error: String(error)
          });
        }
      }

      // å¦‚æœè¿˜æ˜¯æ²¡æœ‰contextï¼Œè¯´æ˜ä¸éœ€è¦åä½œï¼Œç›´æ¥è¿”å›
      if (!context) {
        log("debug", "discord.collaboration.no_context", {
          originalMessageId,
          actualOriginalId,
          hasTriggerMapping: this.triggerMessageMap.has(originalMessageId)
        });
        return;
      }
    }

    // æ ‡è®°å½“å‰botå·²å®Œæˆ
    context.completedBots.add(botUserId);

    // æ‰¾åˆ°å½“å‰botçš„ä½ç½®
    const currentBotIndex = context.botsInChannel.findIndex(b => b.userId === botUserId);
    if (currentBotIndex === -1) {
      log("warn", "discord.collaboration.bot_not_found", { botUserId });
      return;
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªbot
    const nextBotIndex = currentBotIndex + 1;
    if (nextBotIndex >= context.botsInChannel.length) {
      // åä½œå®Œæˆ
      log("info", "discord.collaboration.completed", {
        messageId: actualOriginalId,
        completedBots: Array.from(context.completedBots)
      });
      this.contexts.delete(actualOriginalId);
      return;
    }

    const nextBot = context.botsInChannel[nextBotIndex];

    // è§¦å‘ä¸‹ä¸€ä¸ªbotï¼ˆé€šè¿‡@æåŠï¼‰
    try {
      const channel = await client.channels.fetch(context.channelId);
      if (!channel || !("send" in channel)) {
        log("error", "discord.collaboration.channel_invalid", { channelId: context.channelId });
        return;
      }

      // ã€ä¿®å¤ã€‘åœ¨è§¦å‘æ¶ˆæ¯ä¸­@åŸå§‹ç”¨æˆ·ï¼Œè®©ä¸‹ä¸€ä¸ªbotèƒ½æ­£ç¡®è·å–å¯¹è¯ä¸Šä¸‹æ–‡
      const triggerMessage = `<@${nextBot.userId}> æ¥è‡ª<@${context.initiatorUserId}>çš„é—®é¢˜ ğŸ‘† è¯·ä»ã€${ROLE_DISPLAY_NAMES[nextBot.agentId]}ã€‘è§’åº¦åˆ†æä¸Šè¿°å†…å®¹`;

      const sentMessage = await (channel as any).send({
        content: triggerMessage,
        reply: { messageReference: replyMessage.id }
      });

      // è®°å½•è§¦å‘æ¶ˆæ¯ID -> åŸå§‹æ¶ˆæ¯ID çš„æ˜ å°„ï¼Œç”¨äºåç»­botå›å¤æ—¶è¿½æº¯
      if (sentMessage && sentMessage.id) {
        this.triggerMessageMap.set(sentMessage.id, actualOriginalId);
      }

      log("info", "discord.collaboration.next_bot_triggered", {
        currentBot: context.botsInChannel[currentBotIndex].agentId,
        nextBot: nextBot.agentId,
        nextBotUser: nextBot.username,
        triggerMessageId: sentMessage?.id,
        originalMessageId: actualOriginalId
      });
    } catch (error) {
      log("error", "discord.collaboration.trigger_failed", {
        nextBot: nextBot.agentId,
        error: String(error)
      });
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸçš„ä¸Šä¸‹æ–‡ï¼ˆé˜²æ­¢å†…å­˜æ³„æ¼ï¼‰
   */
  cleanup(): void {
    // æ¸…ç†1å°æ—¶å‰çš„ä¸Šä¸‹æ–‡
    const now = Date.now();
    const oneHourAgo = now - 60 * 60 * 1000;

    // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥è®°å½•åˆ›å»ºæ—¶é—´
    // æš‚æ—¶ä¿ç•™æ‰€æœ‰ä¸Šä¸‹æ–‡ï¼Œç”±å®Œæˆå›è°ƒæ¸…ç†
  }

  /**
   * æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦æ˜¯åä½œè§¦å‘æ¶ˆæ¯
   */
  isCollaborationTrigger(message: Message): boolean {
    const content = message.content.toLowerCase();
    return content.includes("è¯·ä»ã€") && content.includes("ã€‘è§’åº¦åˆ†æ");
  }
}

// å…¨å±€å•ä¾‹
export const collaborationOrchestrator = new CollaborationOrchestrator();
