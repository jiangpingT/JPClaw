# JPClaw 项目记忆 (Project Memory)

**维护**: Claude Code + mlamp
**最后更新**: 2026-02-18

---

## 🎯 核心工作原则

### 代码审查标准 ⭐⭐⭐⭐⭐

**重要性**: 最高优先级
**制定日期**: 2026-02-18

**必须使用最最严格的标准，对标世界级代码库进行代码Review**

#### 核心要求

不满足于表面的代码问题，要深入发现**最最深层的架构和设计问题**。

包括但不限于：

1. **架构设计**: 设计模式、SOLID原则、依赖关系、模块化、可扩展性、代码重用
2. **系统设计**: 并发模型、错误处理策略、资源管理、状态管理、数据流、性能热点
3. **代码实现**: 算法效率、数据结构、边界条件、类型安全、内存泄漏、代码异味
4. **安全性**: 注入攻击、DoS防护、数据验证、密码学、权限控制
5. **可维护性**: 代码可读性、测试覆盖、文档完整性、错误消息、日志策略
6. **性能层面**: I/O优化、计算优化、网络优化、内存优化

#### 评分标准（对标世界级）

- **10/10**: Linux Kernel, Redis, PostgreSQL 级别
- **9.0-9.9/10**: 世界级开源库水平
- **8.0-8.9/10**: 优秀工业级代码
- **7.0-7.9/10**: 良好但有改进空间
- **<7.0/10**: 需要重点改进

#### 当前项目状态

- **第一轮审查**: 7.0/10
- **第二轮审查**: 8.4/10（修复timer泄漏、async错误）
- **第三轮审查**: 9.0/10（修复单例竞态、文件锁）
- **第四轮审查**: 6.2/10（使用最严格标准，发现架构深层问题）
- **P0修复后**: 8.5/10（修复6个阻塞性问题）

#### 目标

- **短期**: 9.0/10（修复P1问题）
- **中期**: 9.5/10（优秀水平）
- **长期**: 10/10（世界级水平）

详细标准参见：`CODE_REVIEW_STANDARDS.md`

---

## 📚 项目知识

### 架构特点

#### 多Agent系统
- 支持多个Discord bot协作
- Agent路由器（MultiAgentRouter）
- 使用Base64+JSON编码的命名空间（防止身份冲突）

#### 增强记忆系统
- 向量化存储 + BM25混合检索
- 智能冲突检测和解决
- 知识图谱集成
- 记忆生命周期管理（自动升级、降级、淘汰）
- 支持依赖注入（IVectorStore接口）
- 事务性保证（TransactionLog）

#### 安全架构
- 分离的中间件（securityHeaders, rateLimit, resourceProtection, auth）
- Admin API强制token验证
- CORS完整支持
- 请求体大小限制、并发控制、超时机制
- 时序攻击防护（timingSafeEqual）

#### 监控和健康检查
- 完整的指标收集系统
- K8s兼容的readiness/liveness端点
- 性能快照自动保存
- Provider健康检查

#### 并发安全
- Promise队列替代布尔互斥锁
- AsyncLocalStorage用于请求上下文
- 防竞态单例实现
- 原子文件写入（临时文件+重命名）

---

## 🔧 技术债务

### 已解决（P0）
- ✅ Admin API安全漏洞
- ✅ CORS配置完善
- ✅ Agent路由身份空间污染
- ✅ 并发控制互斥量
- ✅ 依赖注入解耦
- ✅ 内存操作事务性保证

### 待解决（P1 - 高优先级）
- [ ] SessionKey构造歧义
- [ ] 状态管理分散在8个Map中
- [ ] 速率限制绕过风险
- [ ] 混合搜索多次重复排序
- [ ] 向量搜索中的高频对象创建
- [ ] 冲突检测O(n²)时间复杂度
- [ ] 输入验证不完整
- [ ] 代码重复（DRY违反）
- [ ] 魔法数字散布
- [ ] 缺乏类型安全
- [ ] 关键逻辑文档缺失
- [ ] 测试覆盖不足

---

## 🎨 设计决策

### 为什么使用Base64编码身份命名空间？
- **问题**: `${agentId}::${userId}`拼接方式，如果userId包含`::`会冲突
- **解决**: `JSON.stringify({ agentId, userId }) -> Base64`
- **优点**: 完全避免分隔符冲突，可安全存储任何字符

### 为什么使用Promise队列替代布尔互斥锁？
- **问题**: 布尔值`saveMutex`在JavaScript异步环境中不可靠
- **解决**: `saveQueue = saveQueue.then(() => doSave())`
- **优点**: 真正的串行化执行，自动处理pending

### 为什么实现依赖注入？
- **问题**: 全局导入导致无法单元测试、无法切换实现
- **解决**: IVectorStore接口 + 可选构造函数注入
- **优点**: 易于测试、易于扩展、清晰的依赖关系

### 为什么需要事务日志？
- **问题**: 冲突解决失败时回滚不完整，可能导致数据不一致
- **解决**: TransactionLog记录所有操作，支持原子性回滚
- **优点**: 数据一致性保证、清晰的错误处理

---

## 🚀 开发流程

### 代码审查流程
1. **全局审查**（30分钟）：架构设计、模块依赖
2. **深度审查**（2-4小时）：逐个维度检查
3. **报告生成**（30分钟）：问题汇总、评分、建议
4. **持续跟踪**：修复进度、效果验证

### 修复优先级
- **P0**: 立即修复（阻塞性问题）
- **P1**: 本周内（高优先级）
- **P2**: 本月内（中优先级）
- **P3**: 长期改进（低优先级）

---

## 📝 重要文件

- `CODE_REVIEW_STANDARDS.md` - 完整的审查标准
- `FOURTH_REVIEW_REPORT.md` - 第四轮审查报告
- `P0_FIXES_COMPLETE.md` - P0问题修复报告
- `CRITICAL_FIXES_APPLIED.md` - 关键修复历史
- `CONFIGURATION.md` - 配置文档
- `CLAUDE.md` - Claude Code配置

---

## 🎓 经验教训

### 成功案例
1. **AsyncLocalStorage**: 解决了Trace ID全局状态污染
2. **Promise队列**: 比布尔互斥锁更可靠
3. **依赖注入**: 提高了可测试性和可扩展性
4. **事务日志**: 保证了数据一致性

### 避免的陷阱
1. ❌ 不要使用字符串拼接构造复合key（会冲突）
2. ❌ 不要使用布尔值作为互斥锁（不可靠）
3. ❌ 不要在未设置admin token时允许访问（严重漏洞）
4. ❌ 不要忽略回滚失败（可能导致数据不一致）

---

## 🔄 持续改进

这份记忆将随着项目发展持续更新。

**下一步**:
1. 修复P1高优先级问题
2. 提高测试覆盖率
3. 完善文档
4. 性能优化

**最终目标**: 代码质量达到世界级水平（10/10）🚀

---

**最后更新**: 2026-02-18
**维护者**: Claude Code + mlamp
